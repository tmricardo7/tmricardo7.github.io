"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"first-blog-post","metadata":{"permalink":"/blog/first-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2022-12-28-minimal-api-dotnet7-aws/index.md","source":"@site/blog/2022-12-28-minimal-api-dotnet7-aws/index.md","title":"Minimal API in .NET 7 using AWS Lambda","description":"The newest version of .NET is already released and it comes with a LOT of new improvements that we might want to have in our APIs, including the new C# 11 that is used by default.","date":"2022-12-28T00:00:00.000Z","formattedDate":"December 28, 2022","tags":[{"label":"hola","permalink":"/blog/tags/hola"},{"label":"docusaurus","permalink":"/blog/tags/docusaurus"}],"readingTime":7.11,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"first-blog-post","title":"Minimal API in .NET 7 using AWS Lambda","tags":["hola","docusaurus"]}},"content":"The newest version of .NET is already released and it comes with a LOT of new improvements that we might want to have in our APIs, including the new C# 11 that is used by default.\\n\\nMinimal APIs is one of the most popular features that were added in .NET 6, taking so much love from all the .NET community, as they are a **lightweight** alternative to the controllers that have been used for a long time.\\n\\nWith the new .NET 7 version there are more features for Minimal APIs, for example:\\n\\n- **Filters** that provide a way to add business logic before or after the execution of the endpoint, these are the equivalent of what we used in the old-fashioned Web API controllers, using the `IActionFilter`.\\n- Improved **OpenAPI** support to describe our endpoints using the NuGet package [Microsoft.AspNetCore.OpenApi](https://www.nuget.org/packages/Microsoft.AspNetCore.OpenApi/)\\n\\nYou can see all the new features on the official site [Minimal API in .NET 7](https://learn.microsoft.com/en-us/aspnet/core/release-notes/aspnetcore-7.0?view=aspnetcore-7.0#minimal-apis)\\n\\n#### .NET in AWS Lambda\\n\\nAWS Lambda supports .NET runtime, but only the Long Term Support (LTS) versions, for now .NET Core 3.1 and .NET 6. \\n\\nSo, what if we want to deploy a .NET 7 app into AWS Lambda??\\n\\n### Deploying a .NET 7 Minimal API into AWS Lambda\\n\\n#### The basics\\n\\nFirst, we need a minimal API created. In this case, this will be our app, which is the template provided by .NET when creating a new API in .NET 7.\\n\\n*Program.cs*\\n```csharp\\nvar builder = WebApplication.CreateBuilder(args);\\n\\n// Add services to the container.\\n// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle\\nbuilder.Services.AddEndpointsApiExplorer();\\nbuilder.Services.AddSwaggerGen();\\n\\nvar app = builder.Build();\\n\\n// Configure the HTTP request pipeline.\\nif (app.Environment.IsDevelopment())\\n{\\n    app.UseSwagger();\\n    app.UseSwaggerUI();\\n}\\n\\napp.UseHttpsRedirection();\\n\\nvar summaries = new[]\\n{\\n    \\"Freezing\\", \\"Bracing\\", \\"Chilly\\", \\"Cool\\", \\"Mild\\", \\"Warm\\", \\"Balmy\\", \\"Hot\\", \\"Sweltering\\", \\"Scorching\\"\\n};\\n\\napp.MapGet(\\"/weatherforecast\\", () =>\\n{\\n    var forecast = Enumerable.Range(1, 5).Select(index =>\\n        new WeatherForecast\\n        (\\n            DateOnly.FromDateTime(DateTime.Now.AddDays(index)),\\n            Random.Shared.Next(-20, 55),\\n            summaries[Random.Shared.Next(summaries.Length)]\\n        ))\\n        .ToArray();\\n    return forecast;\\n})\\n.WithName(\\"GetWeatherForecast\\")\\n.WithOpenApi();\\n\\napp.Run();\\n\\ninternal record WeatherForecast(DateOnly Date, int TemperatureC, string? Summary)\\n{\\n    public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);\\n}\\n\\n```\\n\\n\\nSo, to be able to host your app in an AWS Lambda environment you will need to add the NuGet package\\n[Amazon.Lambda.AspNetCoreServer.Hosting](https://www.nuget.org/packages/Amazon.Lambda.AspNetCoreServer.Hosting/1.3.1) to your project and add the following code into yours.\\n\\n```csharp\\nbuilder.Services.AddAWSLambdaHosting(LambdaEventSource.HttpApi);\\n```\\n\\n`AddAWSLambdaHosting` enables us to run our app in AWS Lambda, and we use `LambdaEventSource.HttpApi` because we will use an **API Gateway** of type **HTTP API**.\\n\\nOk now we have our Minimal API app ready to deploy!\\n\\n#### Creating the AWS Lambda\\n\\nIf we go to the AWS Console to create a new Lambda Function, we will see the supported runtimes \\n\\n![](Pasted%20image%2020221202125442.png)\\n\\nAs we already know AWS Lambda doesn\'t support the .NET 7 runtime, so what should we do?? \\n\\nWell AWS Lambda offers two ways to be to do it. First, we can use a container image with .NET 7, or the second way we will use is to use the Lambda custom runtime ability.\\n\\n\\nThere are some requirements to run our app in a custom runtime.\\n\\n1. We will need to provide a Zip with an executable called `bootstrap`.\\n2. We need a **self-contained app**, this can be specified in our app publish settings. \\n3. We also need to set our release for `linux_x64`, this is because AWS uses **Amazon Linux**\\n\\nSo first, we create our function.\\n\\nAs **Runtime** we can select any of the custom runtime options.\\n![](Pasted%20image%2020221202145016.png)\\n\\nIn this app we will use Amazon Linux 2 which is an improved operating system, you can read more about it in the [AWS Official Documentation](https://aws.amazon.com/amazon-linux-2)\\n\\nAs **architecture**, we will use **x86_64**, and then we proceed to create our function!\\n\\n##### Submitting our app\\n\\nNow that we created our Lambda function we can now proceed to upload our code.\\n\\nFirst we will need to set some properties in our `.csproj`\\n\\n```xml\\n  <PropertyGroup>\\n    <OutputType>Exe</OutputType>\x3c!--We first need to have an executable for output, so our custom runtime could know what to execute.--\x3e\\n    <TargetFramework>net7.0</TargetFramework> \x3c!--Part of our app configuration--\x3e\\n    <ImplicitUsings>enable</ImplicitUsings> \x3c!--Part of our app configuration--\x3e\\n    <Nullable>enable</Nullable> \x3c!--Part of our app configuration--\x3e\\n    <AWSProjectType>Lambda</AWSProjectType> \x3c!--Property required to run in AWS Lambda--\x3e \\n    <AssemblyName>bootstrap</AssemblyName> \x3c!--The file that will need to be executed--\x3e \\n  </PropertyGroup>\\n```\\n\\nNotice that we will create an executable called `bootstrap`, this is exactly what we needed as part of our requirements.\\n\\nNow we can publish our app using the following settings.\\n\\n```powershell\\n> dotnet publish -c Release --self-contained true -r linux-x64 -o publish\\n```\\n\\nThis will output our self-contained app in a `publish` folder.\\n\\nNow you will need to zip all the files inside the `publish` folder and upload your code to AWS. So inside our new AWS Lambda function we go to `Upload from` and search for our new .zip file.\\n\\n![](./Pasted%20image%2020221202151524.png)\\n\\nAnd finally, in the Lambda function edit your **Runtime Settings**, and change the Handler property.\\n\\nThe handler property is a way to tell your Lambda what method to invoke, as we named our assembly `bootstrap` we should use the same name in the handler property.\\n\\n![](Pasted%20image%2020221202152101.png)\\n\\nNow your AWS Lambda function is ready! But how can we trigger our endpoints?? and what URL will be used??\\n\\n#### Creating our API Gateway\\n\\nWe now proceed to create an API Gateway in AWS, using the HTTP API type. Then you proceed to select the settings for your integrations, which will connect the routes from the API gateway to our backend resources.\\n\\n![](Pasted%20image%2020221206120453.png)\\n\\n- The Integrations are of type **Lambda**\\n- Select the **region** to lookup at your Lambda Function.\\n- Select your Lambda function\\n- The version doesn\'t matter in this context, so just use `2.0`\\n- And finally, name your new API Gateway\\n\\nWhen creating an API Gateway you can have multiple integrations linked, this means we can link multiple Lambda Functions, but how do we know what lambda to run? \\n\\nWe now need to link our routes to the specific integration. In our case, we will define the route `/weatherforecast` and link it with our Lambda Function. You can add many routes if you want to.\\n\\n![](Pasted%20image%2020221206121450.png)\\n\\nAnd finally in the Stages settings, use the default values.\\n\\nYou can now call the route and test your endpoint.\\n\\nIf everything is good, you will see logs for your Lambda Function in AWS CloudWatch\\n\\n#### Review Performance\\n\\nAWS Cloudwatch provides information about the memory used and the initial time it took to start the Lambda Function and get hot. The Cold Start issue is a common concern that we have to deal in Lambda Functions, our function gets cold if it\'s inactive for a while(5 to 7 minutes), and it will take longer to start again.\\n\\nI tested our new Lambda function and it says:\\n`Max Memory Used: 176 MB Init Duration: 923.70 ms` \\n\\nBy seeing these results, We can see that the performance might not be optimal compared to the same project running on .NET 6, which triggered these results:\\n`Max Memory Used: 82 MB Init Duration: 384.08 ms`\\n\\nThe reason behind this is that we are running a self-contained package which is bigger and it might take more time for the environment to be ready.\\n\\nOk, so .NET 7 brings a lot of good features for our Minimal APIs and we might want to have them without worrying too much about the performance, that\'s ok. But what if we want to improve the performance a little bit more!?\\n\\n#### Native Ahead-of-time(AOT) to the Rescue!\\n\\n.NET 7 brings Native AOT for the very first time in our framework, using this feature we can now create a self-contained app that generated code at application build time, instead of run-time.\\n\\nTo enable AOT in your project just add to your `.csproj` property group.\\n```xml\\n  <PropertyGroup>\\n\\t...\\n    <PublishAot>true</PublishAot>\\n  </PropertyGroup>\\n```\\n\\nNative AOT is very limited for now and we can\'t cross-compile it. So we will need to use Linux to build and publish the zip file. \\n\\nI was able to publish an AOT version of our project into a Lambda Function, I might explain the process in another blog post.\\n\\nFor now I\'m going to post the comparison between .NET 7, .NET 7 AOT and .NET 6.\\n\\n<table><thead><tr><th> Framework Version </th><th> Memory Used</th> <th> Init Duration </th></tr></thead><tbody><tr><td>.NET 6</td><td>82 MB</td><td>384ms</td></tr><tr><td>.NET 7</td><td>176 MB</td><td>923ms</td></tr><tr><td>.NET 7 (AOT)</td><td>105 MB</td><td>389ms</td></tr></tbody></table>\\n\\n```\\n| Framework   | Memory Used | Duration    |\\n| ----------- | ----------- | ----------- |\\n| .NET 6      | 82 MB       | 384ms       |\\n| .NET 7      | 176 MB      | 923ms       |\\n| .NET 7 (AOT)| 105 MB      | 389ms       |\\n```\\n\\nAs you see AOT reduced the memory used by 40% and the duration by almost 60%."}]}')}}]);